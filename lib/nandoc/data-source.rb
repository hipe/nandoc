module NanDoc

  class DataSource < ::Nanoc3::DataSources::FilesystemUnified
    #
    # Make a Nanoc3 DataSource class as necessary to A) pull in
    # content files that exist outside of the <my-site>/content directory and
    # B) allow one of those files to act as the root index page for the
    # generated site, as indicated by config.yaml. and C) rescue orphan
    # files that have a parent directory but no parent file.
    #


    include NanDoc::TaskCommon # task_abort()

    def initialize *a
      super(*a)
      @config = a.last
      @hax_mode = false # this gets turned on when we are doing s/thing weird
    end

    #
    # Hack the items returned by this datasource object to include also
    # files outside of the <my-site>/content directory, e.g. README.md
    # or README/**/*, NEWS.md, based on settings in the config.
    #
    # Rescue orphan nodes with no parent page somehow.
    #
    def items
      @hax_index_page = false
      _ = Nanoc3::Item # autoload it now for easier step debug-ging
      these = super
      dot_dot_names = @config[:source_file_basenames].map{|x| "../#{x}"}
      @hax_mode = true
      additional = dot_dot_names.map do |basename|
        load_objects(basename, 'item', Nanoc3::Item)
      end.flatten(1)
      @hax_mode = false
      error_for_no_files(dot_dot_names) if additional.empty?
      res = these + additional
      # deal_with_index_page_children(res) if @hax_index_page
      orphan_rescue(res)
      res
    end

  private

    #
    # a hook to grab the folder name that later gets stripped out
    # also a supremely ugly hack to get e.g. ../README.md
    #
    def all_split_files_in dir_name
      return super unless @hax_mode
      @hax_last_dir_name = dir_name
      ret = super
      lone_file = "#{dir_name}.md"
      if File.exist?(lone_file) # e.g. '../README.md'
        @hax_last_filename = lone_file.dup
        class << lone_file
          #
          # make it so that it ignores the next + operation in the first
          # line of Nanoc3::DataSources::Filesystem#all_split_files_in()
          # this is shorter and easier than overriding and rewring
          # the above function but it is a supreme haxie guaranteed to fail
          # one day!!!
          #
          def + _; self end
        end
        other = super(lone_file)
        ret.merge!(other)
      end
      ret
    end

    # Let's see if rescuing orphans fixes this.
    #
    #
    #
    # I *think* we want this.   See if it makes sense in the site map.
    # Site#setup_child_parent_links() sets up this stuff later,
    # we need to make a new node to stand in for the one we lost or
    # etc etc
    #
    # def deal_with_index_page_children items
    #   # note @hax_mode must be off below
    #   would_have_been = identifier_for_filename @config[:use_as_main_index]
    #   re1 = /\A#{Regexp.escape(would_have_been)}/
    #   re2 = /\A#{Regexp.escape(would_have_been)}(.+)\Z/
    #   orphans = items.select{|x| x.identifier =~ re1 }
    #   orphans.each do |orph|
    #     re2 =~ orph.identifier or fail("fail")
    #     orph.identifier = "/#{$1}"
    #   end
    # end

    #
    # We crap out if we didn't find any weird files because after all
    # this is NanDoc.
    #
    def error_for_no_files files
      task_abort <<-HERE.gsub(/\n +/,"\n").strip
      No matching content file(s) found at or under (#{files.join(', ')})
      from here. (This corresponds to the 'source_file_basenames' setting in
      config.yaml.)  Did you generate the NanDoc site in the right directory?
      HERE
    end

    #
    # more crazy hacks - normally content/foo/bar.html => "/foo/bar/" but
    # for this case we don't want to have stripped the containing folder,
    # *and* we try to hack it so that it's laid alongside content in
    # the content folder for the final site.
    #
    def identifier_for_filename fn
      return super unless @hax_mode
      if 'md' == fn # there has to be a better way :(
        /\A\.\.\/(.*)\Z/ =~ @hax_last_filename or fail('hack fail 1')
        if $1 == @config[:use_as_main_index] # 'README.md'
          identifier = '/' # overwrite the index.html generated by nandoc!
          @hax_index_page = true
        else
          identifier = super($1) # '../README.md' => 'README.md' => '/README/'
        end
      else
        /\A\.\.(.*)\Z/ =~ @hax_last_dir_name or fail('hack fail 2')
        without = super(fn) # $1 => '/README' without => '/foo/'
        identifier = "#{$1}#{without}"
      end
      identifier
    end

    #
    # A) Experimentally generate index pages for child nodes without them
    # B) merge many filesystem roots to one docroot (hack!) per 'basenames'
    # (undefined on name collision)
    #
    def orphan_rescue items
      Orphanage.rescue_orphans(@config, items)
    end

  private

    module ItemMethods
      # must have @items.  make public if u need it

      def find_parent item_identifier
        parent_path = parent_identifier(item_identifier)
        parent = @items.find { |p| p.identifier == parent_path }
        parent
      end
      def identifier_bare_rootname identifier
        /\A\/([^\/]+)\// =~ identifier and $1
      end
      def identifier_bare_rootname_assert identifier
        identifier_bare_rootname(identifier) or
          fail("hack fail: couldn't find rootname for #{identifier.inspect}")
      end
      # exactly one leading and one trailing slash
      def identifier_strip identifier
        /\A\/(.+)\/\Z/ =~ identifier and $1
      end
      def identifier_strip_assert identifier
        identifier_strip(identifier) or fail("hack fail: #{identifier}")
      end
      def parent_identifier identifier
        identifier.sub(/[^\/]+\/$/, '')
      end
      def site_root
        @site_root ||= @items.find{|x| x.identifier == '/' }
      end
    end

    class Orphanage
      #
      # @api private implementation for experimental orphan_rescue()
      #
      include ItemMethods
      class << self
        def rescue_orphans config, items
          new(config, items).rescue_orphans
        end
        private :new
      end

      def rescue_orphans
        items = @items.map # we are going to add to it in loop below
        items.each do |item|
          next unless is_orphan? item
          id = item.identifier
          parent_id = parent_identifier(id)
          bare_root = identifier_bare_rootname_assert(id)
          bare_parent = identifier_strip_assert(parent_id)
          new_id = nil
          @renamer = nil
          if @basenames.include?(bare_root)
            # then we need to hack a rename to the identifier
            @renamer = /\A\/#{Regexp.escape(bare_root)}\/(.+)\Z/
            new_id = rename(id)
          end
          if (!new_id || bare_parent!=bare_root) && is_orphan?(item, new_id)
            make_surrogate_parent parent_id
          end
          item.identifier = new_id if new_id
        end
      end
    private
      def initialize config, items
        @basenames = config[:source_file_basenames] || []
        @items = items
      end

      def is_orphan? item, using_identifier=nil
        item.nandoc_content_leaf? or return false
        using_identifier ||= item.identifier
        parent = find_parent using_identifier
        parent.nil? && using_identifier != '/'
      end

      def make_surrogate_parent parent_id
        use_id = @renamer ? rename(parent_id) : parent_id
        use_path = @renamer ? "../#{parent_id}" : parent_id
        content = surrogate_content
        fake_parent = Nanoc3::Item.new(
          content,
          {:filename => use_path, :content_filename => use_path },
          use_id
        )
        @items.unshift(fake_parent)
      end

      # don't use this
      def rename str
        @renamer =~ str or
          fail("rename fail: #{str.inspect} against #{@rename}")
        renamed = "/#{$1}"
        renamed
      end

      def surrogate_content
        @surrogate_content ||= begin
          File.read(NanDoc::Config.orphan_surrogate_filename)
        end
      end
    end
  end
end
