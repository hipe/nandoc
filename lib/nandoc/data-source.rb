module NanDoc

  class DataSource < ::Nanoc3::DataSources::FilesystemUnified
    #
    # Make a Nanoc3 DataSource class as necessary to A) pull in
    # content files that exist outside of the <my-site>/content directory and
    # B) allow one of those files to act as the root index page for the
    # generated site, as indicated by config.yaml.
    #


    include NanDoc::TaskCommon # task_abort()

    def initialize *a
      super(*a)
      @config = a.last
      @hax_mode = false # this gets turned on when we are doing s/thing weird
    end

    #
    # Hack the items returned by this datasource object to include also
    # files outside of the <my-site>/content directory, e.g. README.md
    # or README/**/*, NEWS.md, based on settings in the config.
    #
    # Rescue orphan nodes with no parent page somehow.
    #
    def items
      @hax_index_page = false
      _ = Nanoc3::Item # autoload it now for easier step debug-ging
      these = super
      dot_dot_names = @config[:source_file_basenames].map{|x| "../#{x}"}
      @hax_mode = true
      additional = dot_dot_names.map do |basename|
        load_objects(basename, 'item', Nanoc3::Item)
      end.flatten(1)
      @hax_mode = false
      error_for_no_files(dot_dot_names) if additional.empty?
      res = these + additional
      # deal_with_index_page_children(res) if @hax_index_page
      rescue_orphans(res)
      res
    end

  private

    #
    # a hook to grab the folder name that later gets stripped out
    # also a supremely ugly hack to get e.g. ../README.md
    #
    def all_split_files_in dir_name
      return super unless @hax_mode
      @hax_last_dir_name = dir_name
      ret = super
      lone_file = "#{dir_name}.md"
      if File.exist?(lone_file) # e.g. '../README.md'
        @hax_last_filename = lone_file.dup
        class << lone_file
          #
          # make it so that it ignores the next + operation in the first
          # line of Nanoc3::DataSources::Filesystem#all_split_files_in()
          # this is shorter and easier than overriding and rewring
          # the above function but it is a supreme haxie guaranteed to fail
          # one day!!!
          #
          def + _; self end
        end
        other = super(lone_file)
        ret.merge!(other)
      end
      ret
    end

    # Let's see if rescuing orphans fixes this.
    #
    #
    #
    # I *think* we want this.   See if it makes sense in the site map.
    # Site#setup_child_parent_links() sets up this stuff later,
    # we need to make a new node to stand in for the one we lost or
    # etc etc
    #
    # def deal_with_index_page_children items
    #   # note @hax_mode must be off below
    #   would_have_been = identifier_for_filename @config[:use_as_main_index]
    #   re1 = /\A#{Regexp.escape(would_have_been)}/
    #   re2 = /\A#{Regexp.escape(would_have_been)}(.+)\Z/
    #   orphans = items.select{|x| x.identifier =~ re1 }
    #   orphans.each do |orph|
    #     re2 =~ orph.identifier or fail("fail")
    #     orph.identifier = "/#{$1}"
    #   end
    # end

    #
    # We crap out if we didn't find any weird files because after all
    # this is NanDoc.
    #
    def error_for_no_files files
      task_abort <<-HERE.gsub(/\n +/,"\n").strip
      No matching content file(s) found at or under (#{files.join(', ')})
      from here. (This corresponds to the 'source_file_basenames' setting in
      config.yaml.)  Did you generate the NanDoc site in the right directory?
      HERE
    end

    #
    # more crazy hacks - normally content/foo/bar.html => "/foo/bar/" but
    # for this case we don't want to have stripped the containing folder,
    # *and* we try to hack it so that it's laid alongside content in
    # the content folder for the final site.
    #
    def identifier_for_filename fn
      return super unless @hax_mode
      if 'md' == fn # there has to be a better way :(
        /\A\.\.\/(.*)\Z/ =~ @hax_last_filename or fail('hack fail 1')
        if $1 == @config[:use_as_main_index] # 'README.md'
          identifier = '/' # overwrite the index.html generated by nandoc!
          @hax_index_page = true
        else
          identifier = super($1) # '../README.md' => 'README.md' => '/README/'
        end
      else
        /\A\.\.(.*)\Z/ =~ @hax_last_dir_name or fail('hack fail 2')
        without = super(fn) # $1 => '/README' without => '/foo/'
        identifier = "#{$1}#{without}"
      end
      identifier
    end

    #
    # Experimentally generate index pages for child nodes without them
    #
    def rescue_orphans items
      surrogate_content = File.read(NanDoc::Config.orphan_surrogate_filename)
      items.each do |item|
        parent_identifier = item.identifier.sub(/[^\/]+\/$/, '')
        parent = items.find { |p| p.identifier == parent_identifier }
        basenames = @config[:source_file_basenames] || []
        if parent.nil? && item.identifier != '/' && item.nandoc_content_leaf?
          (/\A\/([^\/]+)\// =~ item.identifier) && (base = $1) or fail('no')
          dot_dot = basenames.include?(base) ? '..' : ''
          fake_path = dot_dot + item.identifier
          fake_item = Nanoc3::Item.new(
            surrogate_content,
            {:filename => fake_path, :content_filename=> fake_path },
            parent_identifier
          )
          items.unshift(fake_item)
        end
      end
    end
  end
end
